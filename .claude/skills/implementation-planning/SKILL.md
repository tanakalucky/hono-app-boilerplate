---
name: implementation-planning
description: 設計書から実装可能なタスクに分解し、依存関係を整理して実装順序を決定するスキル。ブランチ戦略とコミット単位のサブタスクを含む実装チェックリストを生成する。
---

# 実装計画スキル

このスキルは、設計書を受け取り、実装エージェントが使用する詳細な実装計画書（チェックリスト形式）を生成する。

## 目的

- 設計書を実装可能なタスクに分解
- タスク間の依存関係を明確化
- 効率的な実装順序を決定
- ブランチ戦略を提案
- Conventional Commits形式（日本語版）に準拠したコミット単位のサブタスクを定義

## 前提条件

このスキルを使用する前に、以下が完了していること：
- 要件定義が完了している（`.ai-workspace/{branch}/01-requirements.md`）
- 設計書が存在する（`.ai-workspace/{branch}/02-design.md`）

**設計書の確認：**
実装計画を作成する前に、必ず `.ai-workspace/{branch}/02-design.md` を確認してください。設計書が存在しない場合は、設計エージェントで設計を完了させてから実装計画を作成することを推奨します。

## インプット

設計書には以下が含まれている想定：
- システムアーキテクチャ
- データモデル/スキーマ
- API仕様
- コンポーネント構成
- 技術スタック

## タスク分割の方針

### タスクの粒度

**1タスク = 1つの機能や変更の単位**

例：
- ✅ 「ユーザー認証機能の実装」
- ✅ 「ダッシュボードのデータ表示機能」
- ✅ 「検索機能の実装」
- ❌ 「バックエンド全体の実装」（大きすぎる）
- ❌ 「ボタンの色変更」（小さすぎる）

### タスク分割の基準

1. **機能単位で分割**
   - ユーザーから見た1つの機能
   - 独立してテスト・デプロイ可能な単位

2. **技術的な境界で分割**
   - フロントエンドとバックエンドは別タスク可能
   - ただし、相互依存が強い場合は1タスクにまとめる

3. **複雑度を考慮**
   - 1タスクの実装時間：2〜8時間を目安
   - それ以上かかる場合は分割を検討

## 依存関係の整理

### 依存関係のパターン

1. **技術的依存**
   - データモデル → API → UI の順
   - 認証機能 → 認証が必要な機能

2. **ビジネスロジック依存**
   - 基本機能 → 応用機能
   - CRUD → 検索/フィルタリング

3. **並列実装可能**
   - 依存関係のないタスク
   - 異なるモジュール/コンポーネント

### 依存関係の表記

実装計画書では、各タスクに依存関係を明記します：

```markdown
### タスク2: ダッシュボード機能

**優先度**: P1
**依存**: タスク1（ユーザー認証）
**ブランチ**: feature/dashboard
**見積もり**: 6時間
```

複数のタスクに依存する場合：

```markdown
**依存**: タスク1, タスク2
```

## 実装順序の決定

### 基本原則

1. **ボトムアップ**: 依存される側から実装
2. **リスク優先**: 技術的に不確実な部分を先に
3. **MVP思考**: 最小限の動作する機能から

### 優先順位の決定

- **P0（最優先）**: システムの基盤、他のタスクの依存元
- **P1（高）**: コア機能
- **P2（中）**: 重要だが後回し可能
- **P3（低）**: あったら嬉しい機能

## ブランチ戦略

### 基本戦略

**小〜中規模の機能**: 1つのfeatureブランチで複数コミット

```
main
 └── feature/user-auth
      ├── commit: feat(api): ログインエンドポイントを追加
      ├── commit: feat(api): JWTトークン生成ロジックを追加
      ├── commit: feat(components): ログインフォームを追加
      └── commit: test(api): 認証APIのテストを追加
```

**大規模な機能**: タスクごとにブランチを切る

```
main
 ├── feature/task-1 (マージ)
 ├── feature/task-2 (タスク1マージ後に作業)
 └── feature/task-3 (タスク2マージ後に作業)
```

### ブランチ命名規則

- `feature/[機能名]`: 新機能
- `fix/[問題名]`: バグ修正
- `refactor/[対象]`: リファクタリング

例：
- `feature/user-auth`
- `feature/dashboard`
- `fix/login-validation`

## コミット単位のサブタスク化

### コミット規約への準拠

**重要**: このスキルでは、既存の `.claude/skills/commit-convention/SKILL.md` で定義されたConventional Commits形式（日本語版）に厳密に従います。

コミットメッセージの詳細な形式、type、scope、メッセージの書き方については、必ず `.claude/skills/commit-convention/SKILL.md` を参照してください。

### サブタスクの分割方針

1タスクを以下の観点でコミット単位に分割：

1. **実装レイヤーごと**
   - データモデル/型定義
   - APIエンドポイント
   - ビジネスロジック
   - UIコンポーネント
   - テスト

2. **機能の段階ごと**
   - 基本実装
   - エラーハンドリング
   - バリデーション
   - 最適化

3. **1コミット = 1つの論理的変更**
   - 型定義の追加
   - APIハンドラーの実装
   - コンポーネントの作成

## 実装計画書の生成フォーマット

実装計画書のテンプレートは、別ファイルで定義されています：

**テンプレート**: `.claude/skills/implementation-planning/templates/implementation-plan.md`

このテンプレートには以下が含まれています：
- 実装計画書の基本構造
- タスクの記述フォーマット
- サブタスク（コミット単位）の記載方法
- 実装上の注意事項
- 具体的な例（ユーザー管理システム）

生成される実装計画書は、このテンプレートに従って作成されます。

## ワークスペース構造

実装計画書は以下のディレクトリに保存します：

```
.ai-workspace/
└── {branch-name}/          # 現在のブランチ名
    ├── 01-requirements.md  # 要件定義書（前工程で作成）
    ├── 02-design.md        # 設計書（前工程で作成）
    ├── 03-implementation-plan.md  # 実装計画書（この工程で作成）
    └── assets/             # 図表など
```

### ファイル命名規則

- 番号プレフィックス: 作成順序を示す（01, 02, 03...）
- `03-implementation-plan.md`: 実装計画書
- Markdownフォーマット: すべて `.md` 形式

## 実装計画生成の手順

### ステップ1: 設計書の読み込みと理解

**目的**: 設計書から実装に必要な情報を抽出する

**作業内容**:
- `.ai-workspace/{branch}/02-design.md` を読み込む
- アーキテクチャ図を確認
- データモデル/スキーマを把握
- API仕様を理解
- コンポーネント構成を確認
- 技術スタックを確認

**アウトプット**: 設計の全体像の理解

---

### ステップ2: タスクの洗い出しと分割

**目的**: 設計を実装可能なタスクに分解する

**作業内容**:
- 設計書から実装すべき機能をリストアップ
- 機能単位でタスクに分割（2〜8時間/タスクを目安）
- 各タスクに名前と説明を付ける
- タスクの粒度を確認（大きすぎる場合は分割、小さすぎる場合は統合）

**アウトプット**: タスク一覧（名前と概要のみ）

---

### ステップ3: 依存関係の分析と整理

**目的**: タスク間の依存関係を明確化する

**作業内容**:
- 各タスクの依存関係を洗い出す
- 技術的依存（データモデル → API → UI）を確認
- ビジネスロジック依存（基本機能 → 応用機能）を確認
- DAG（有向非巡回グラフ）を意識して整理
- 循環依存がないか確認
- 並列実装可能なタスクを特定

**アウトプット**: タスクと依存関係のグラフ

---

### ステップ4: 優先順位の決定と実装順序の策定

**目的**: 効率的な実装順序を決定する

**作業内容**:
- 依存関係をもとに実装順序を決定
- リスクの高いタスク（技術的に不確実な部分）を優先
- MVP（最小限の動作する製品）を意識
- 優先度（P0〜P3）を各タスクに割り当て

**判断基準**:
- **P0（最優先）**: システムの基盤、他のタスクの依存元
- **P1（高）**: コア機能
- **P2（中）**: 重要だが後回し可能
- **P3（低）**: あったら嬉しい機能

**アウトプット**: 優先順位付きタスク一覧

---

### ステップ5: サブタスクへの分割（コミット単位）

**目的**: 各タスクをコミット単位のサブタスクに分解する

**作業内容**:
- 各タスクを実装レイヤーごとに分割（データモデル、API、UI、テスト）
- 機能の段階ごとに分割（基本実装、エラーハンドリング、バリデーション）
- Conventional Commits形式に準拠したコミットメッセージを作成
- 1コミット = 1つの論理的変更を維持

**参照**: `.claude/skills/commit-convention/SKILL.md`

**アウトプット**: コミット単位のサブタスク一覧

---

### ステップ6: 見積もりの算出

**目的**: 各タスクの実装時間を見積もる

**作業内容**:
- サブタスクの数と複雑度から判断
- 2〜8時間を目安に調整
- 見積もりが8時間を超える場合は、タスクの分割を再検討

**アウトプット**: 見積もり時間付きタスク一覧

---

### ステップ7: ブランチ戦略の決定

**目的**: プロジェクトの規模に応じたブランチ戦略を選択する

**判断基準**:
- 小〜中規模: 1タスク = 1featureブランチ（複数コミット）
- 大規模: 並列実装可能なタスクは複数ブランチ同時進行

**アウトプット**: ブランチ戦略とブランチ名

---

### ステップ8: 実装計画書の生成

**目的**: テンプレートに従って実装計画書を生成する

**作業内容**:
- テンプレート（`.claude/skills/implementation-planning/templates/implementation-plan.md`）に従ってMarkdown形式で出力
- タスクの依存関係を明記
- 技術的な注意点を記載
- `.ai-workspace/{branch}/03-implementation-plan.md` に保存

**アウトプット**: 実装計画書

## よくある間違いと対策

### ❌ タスクが大きすぎる

**問題例**: 「フロントエンド全体の実装」「バックエンドAPI全部」

このような粒度では実装計画として機能しません。見積もりができず、進捗も追えません。

✅ **対策**: 機能単位に分割し、2〜8時間で完了する粒度にする。

**改善例**:
- ❌ 「フロントエンド全体の実装」
- ✅ 「ログインフォームの実装」「ダッシュボードの実装」「設定画面の実装」

---

### ❌ 依存関係を無視している

**問題例**: UIコンポーネントの実装をAPIより先にスケジュールする

依存関係を考慮せずに順序を決めると、実装中に手戻りが発生します。

✅ **対策**: データモデル → API → UI の順を基本とし、依存関係を明記する。

**改善例**:
- ❌ タスク1: ログインフォーム → タスク2: 認証API
- ✅ タスク1: 認証API → タスク2: ログインフォーム

---

### ❌ サブタスクが細かすぎる

**問題例**: 「変数名を変更」「スペースを追加」「コメントを修正」

このレベルのサブタスクは不要です。コミットが増えすぎて逆に分かりにくくなります。

✅ **対策**: 1つの論理的な変更をサブタスクとする。

**改善例**:
- ❌ 「User型を定義」「userId変数を追加」「userNameを追加」
- ✅ 「feat(api): User型とユーザーテーブルのスキーマを定義」

---

### ❌ サブタスクが大きすぎる

**問題例**: 「feat(api): 認証機能を実装」（実際には登録、ログイン、JWT生成、ミドルウェア全部を1コミット）

1コミットに複数の論理的変更が含まれると、レビューしにくく、ロールバックも困難です。

✅ **対策**: 1コミット = 1つの論理的変更を維持する。

**改善例**:
- ❌ 「feat(api): 認証機能を実装」（全部入り）
- ✅ 
  - 「feat(api): ユーザー登録エンドポイントを追加」
  - 「feat(api): ログインエンドポイントを追加」
  - 「feat(api): JWT認証ミドルウェアを追加」

---

### ❌ コミットメッセージが曖昧

**問題例**: 「修正」「更新」「fix」

何をしたか分からず、履歴を追うのが困難になります。

✅ **対策**: Conventional Commits形式に従い、具体的に記述する。

**改善例**:
- ❌ 「修正」
- ✅ 「fix(api): ログイン時のトークン有効期限チェックを修正」

---

### ❌ 技術的な注意点が抽象的

**問題例**: 「セキュリティに注意」「パフォーマンスを考慮」

抽象的すぎて実装時に役立ちません。

✅ **対策**: 具体的な実装方針や制約を記載する。

**改善例**:
- ❌ 「セキュリティに注意」
- ✅ 「パスワードはbcryptでハッシュ化（コスト係数10）、JWTの有効期限は24時間」

## 実装エージェントへの引き継ぎ

生成された実装計画書は、実装エージェントに以下の情報を提供します：

1. **何を実装するか**: タスクとサブタスクの一覧
2. **どの順番で実装するか**: 依存関係と優先順位
3. **どうコミットするか**: Conventional Commits形式のメッセージ
4. **何に注意するか**: 技術的な注意点

実装エージェントは、この実装計画書に従って：
- タスクを順番に実装
- サブタスクごとにコミット
- 技術的な注意点を考慮
- 完了したタスクにチェックマークを付ける

## まとめ

このスキルを使用することで：
- 設計書から実装可能なタスクに変換
- 依存関係を考慮した効率的な実装順序
- コミット規約に準拠した詳細なサブタスク
- 実装エージェントが迷わず作業できる実装計画書

を生成できます。
