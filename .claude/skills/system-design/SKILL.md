---
name: system-design
description: システム設計プロセスのガイドライン。要件定義書を元に対話でアーキテクチャ、データモデル、API設計を詰める。ADRで重要な決定を記録し、構造化された設計書を出力する。
---

# システム設計プロセス

このスキルは、要件定義書を元にシステム設計を対話形式で詰め、実装可能な設計書とADRを生成するプロセスを定義します。

## 基本方針

### 1. 要件定義書を確認する
- `.ai-workspace/{branch}/01-requirements.md` があるか最初にチェック
- なければ警告を出す（詳細はPhase 1参照）

### 2. フェーズごとに対話する
- 各フェーズで**提案 → フィードバック → 調整**のサイクルを回す
- 一気に全部決めない。段階的に詰める
- ユーザーの理解度を確認しながら進める
- **1回に1つのフェーズ**に集中する

### 3. 技術的判断を明確にする
- **「なぜその技術を選ぶのか」を必ず説明**
- トレードオフを示す（メリット・デメリット）
- 代替案がある場合は提示して比較
- 根拠のない技術選定はしない

### 4. ADRで重要な決定を記録
- 重要な技術選定やアーキテクチャ決定は**ADR化を提案**
- フォーマット: 「これADRに残しますか？理由: [なぜ記録すべきか]」
- ユーザーが承認したらADR生成
- 些細な決定はADR化しない（判断基準は後述）

### 5. 設計書を構造化して出力
- 対話が終わったら設計書を生成
- ファイル配置先: `.ai-workspace/{branch}/02-design.md`
- 図表が必要な箇所にはmermaidを使用

## 対話プロセス

### Phase 1: 要件確認（5分）

**目的**: 要件定義書を読み込み、設計の前提を確認する

**手順**:
1. `.ai-workspace/{branch}/01-requirements.md` を読み込む
2. **なければ警告**:
````
   要件定義書が見つからないけど、このまま設計進めていいか？
   要件が曖昧なまま設計すると後で手戻りが発生するぞ。
   要件定義エージェントで整理してから来た方がいいと思うけど、どうする？
````
3. ユーザーが続行を選択した場合、**要件をヒアリング**
4. 要件をサマって確認: 「こういう理解で進めますね」

**アウトプット**:
- 要件の理解確認
- 設計の前提条件の明確化

---

### Phase 2: アーキテクチャ設計（10-15分）

**目的**: システム全体の構造を決める

**手順**:
1. **アーキテクチャパターンを提案**
   - レイヤードアーキテクチャ
   - マイクロサービス
   - イベント駆動
   - など、要件に応じて選択
2. **主要コンポーネントの分割を提案**
   - フロントエンド、バックエンド、DB、外部サービス連携など
   - 各コンポーネントの責務を明確化
3. **コンポーネント間の関係を図示**
   - mermaidでアーキテクチャ図を提示
4. **フィードバックを受けて調整**
5. **ADR候補があれば確認**
   - 例: 「モノリスじゃなくてマイクロサービスにする理由は〇〇。これADRに残しますか？」

**提案フォーマット**:
````markdown
## アーキテクチャ提案

### 選定パターン: [パターン名]

**理由**:
- [理由1]
- [理由2]

**メリット**:
- [メリット1]
- [メリット2]

**デメリット**:
- [デメリット1]
- [デメリット2]

**代替案**: [もしあれば]

### コンポーネント構成

[mermaid図]

### 各コンポーネントの責務

- **[コンポーネント1]**: [責務]
- **[コンポーネント2]**: [責務]
````

**ADR候補になる決定**:
- アーキテクチャパターンの選定
- フレームワーク/ライブラリの選定
- マイクロサービス vs モノリス
- クラウドプロバイダの選定

---

### Phase 3: データ設計（10-15分）

**目的**: データモデルとDB設計を決める

**手順**:
1. **主要エンティティを洗い出す**
   - 要件定義書の「データ要件」を参照
   - エンティティの属性を定義
2. **リレーションを定義**
   - 1:1, 1:N, N:Nの関係
   - 外部キー制約
3. **正規化の方針を決める**
   - 第3正規形まで正規化するか
   - パフォーマンスのために非正規化するか
4. **ER図を提示**（mermaid）
5. **フィードバックを受けて調整**
6. **ADR候補があれば確認**
   - 例: 「NoSQLじゃなくてRDBにする理由は〇〇。これADRに残しますか？」

**提案フォーマット**:
````markdown
## データモデル提案

### 主要エンティティ

| エンティティ名 | 説明 | 主要属性 |
|--------------|------|---------|
| [Entity1] | [...] | [...] |

### ER図

[mermaid ER図]

### 正規化方針

**選定**: [第3正規形 / 非正規化]

**理由**:
- [理由]

### インデックス戦略

- **[テーブル名]**: [カラム] - [理由]
````

**ADR候補になる決定**:
- DB選定（PostgreSQL vs MySQL vs NoSQL）
- 正規化 vs 非正規化
- パーティショニング戦略
- レプリケーション戦略

---

### Phase 4: API/インターフェース設計（10-15分）

**目的**: 主要なAPIエンドポイントとインターフェースを決める

**手順**:
1. **主要なAPIエンドポイントを洗い出す**
   - ユースケースごとに必要なAPI
   - RESTful設計原則に従う
2. **リクエスト/レスポンス形式を定義**
   - JSON形式
   - 必須/任意パラメータ
3. **エラーハンドリングを定義**
   - HTTPステータスコード
   - エラーレスポンス形式
4. **必要ならシーケンス図を提示**（mermaid）
5. **フィードバックを受けて調整**
6. **ADR候補があれば確認**
   - 例: 「REST APIじゃなくてGraphQLにする理由は〇〇。これADRに残しますか？」

**提案フォーマット**:
````markdown
## API設計提案

### エンドポイント一覧

| メソッド | エンドポイント | 説明 | 認証 |
|---------|--------------|------|------|
| GET | /api/v1/users | ユーザー一覧取得 | 必要 |
| POST | /api/v1/users | ユーザー作成 | 必要 |

### エンドポイント詳細

#### GET /api/v1/users

**説明**: ユーザー一覧を取得

**リクエスト**:
```json
{
  "page": 1,
  "limit": 20
}
```

**レスポンス**:
```json
{
  "users": [...],
  "total": 100,
  "page": 1
}
```

**エラーレスポンス**:
- 401: 認証エラー
- 500: サーバーエラー

### 認証方式

**選定**: [JWT / OAuth2 / API Key]

**理由**:
- [理由]
````

**ADR候補になる決定**:
- API設計方式（REST vs GraphQL vs gRPC）
- 認証方式（JWT vs OAuth2）
- APIバージョニング戦略

---

### Phase 5: 非機能要件の設計（10分）

**目的**: パフォーマンス、セキュリティ、スケーラビリティなどの実現方針を決める

**手順**:
1. **要件定義書の「非機能要件」を参照**
2. **各要件の実現方針を提案**
   - パフォーマンス: キャッシュ戦略、DB最適化など
   - セキュリティ: 認証、認可、暗号化など
   - スケーラビリティ: 水平スケール、ロードバランサなど
3. **フィードバックを受けて調整**
4. **ADR候補があれば確認**

**提案フォーマット**:
````markdown
## 非機能要件の設計

### パフォーマンス

**要件**: [要件定義書から引用]

**実現方針**:
- キャッシュ: Redis使用、TTL 5分
- DB最適化: インデックス、クエリ最適化
- CDN: 静的ファイル配信

### セキュリティ

**要件**: [要件定義書から引用]

**実現方針**:
- 認証: JWT + リフレッシュトークン
- 認可: RBAC
- 暗号化: HTTPS, DB暗号化

### スケーラビリティ

**要件**: [要件定義書から引用]

**実現方針**:
- 水平スケール: Kubernetesでオートスケール
- ロードバランサ: ALB
- DBレプリケーション: マスター-スレーブ構成
````

**ADR候補になる決定**:
- キャッシュ戦略
- セキュリティアーキテクチャ
- スケーリング戦略

---

### Phase 6: サマリ確認（5分）

**目的**: 設計全体を振り返って確認

**手順**:
1. **設計全体をサマって提示**
   - アーキテクチャ
   - データモデル
   - API設計
   - 非機能要件
2. **「この内容で設計書を生成していいか？」と確認**
3. **修正・追加があれば反映**

---

### Phase 7: ドキュメント生成（自動）

**目的**: 設計書とADRを生成

**手順**:
1. **設計書を生成**: `.ai-workspace/{branch}/02-design.md`
   - テンプレート: `.claude/skills/system-design/templates/design-doc.md`
2. **ADRを生成**: `docs/adr/YYYY-MM-DD-{タイトル}.md`
   - テンプレート: `.claude/skills/system-design/templates/adr.md`
3. **ユーザーに確認してもらう**

---

## ADRに記録すべき決定の判断基準

### 記録すべき決定

**アーキテクチャレベル**:
- アーキテクチャパターンの選定（レイヤード、マイクロサービスなど）
- フレームワーク/ライブラリの選定
- クラウドプロバイダの選定
- マイクロサービス vs モノリス

**データレベル**:
- DB選定（PostgreSQL vs MySQL vs NoSQL）
- 正規化 vs 非正規化の方針
- パーティショニング戦略
- レプリケーション戦略

**インターフェースレベル**:
- API設計方式（REST vs GraphQL vs gRPC）
- 認証方式（JWT vs OAuth2）
- APIバージョニング戦略

**非機能要件レベル**:
- キャッシュ戦略（Redis, CDNなど）
- セキュリティアーキテクチャ
- スケーリング戦略

### 記録不要な決定

- 些細なコーディング規約
- 一時的な回避策
- 個別の関数やクラスの設計
- 明らかな選択（例: HTTPSを使う）
- チーム内で当たり前の慣習

**判断の目安**: 「なぜこの選択をしたのか、半年後に説明が必要か？」がYesならADR化を検討

---

## ワークスペース構造

設計書や関連ドキュメントは以下のディレクトリに保存します：
````
.ai-workspace/
└── {branch-name}/          # 現在のブランチ名
    ├── 01-requirements.md  # 要件定義書（前工程で作成）
    ├── 02-design.md        # 設計書（この工程で作成）
    ├── 03-tasks.md         # タスクリスト（後続工程で作成）
    └── assets/             # 図表など

docs/
└── adr/                    # ADR（Architecture Decision Records）
    ├── 2024-12-14-use-postgresql.md
    ├── 2024-12-15-adopt-microservices.md
    └── ...
````

### ファイル命名規則
- 設計書: `02-design.md`（番号プレフィックスで順序を示す）
- ADR: `YYYY-MM-DD-タイトル.md`
- Markdownフォーマット: すべて `.md` 形式
- mermaid図: 設計書内に埋め込む

---

## 注意事項

### やること
- **要件定義書を必ず確認**（なければ警告）
- **技術選定の根拠を明確にする**
- **トレードオフを説明する**
- **ADRで重要な決定を記録する**
- **ユーザーのフィードバックを反映する**
- **図表を使って分かりやすく説明する**

### やらないこと
- **根拠なく技術を選定しない**
- **一度に全部決めない**（フェーズごとに進める）
- **ユーザーを置いてけぼりにしない**（理解度を確認）
- **些細な決定をADR化しない**
- **実装の話はしない**（設計に集中）

---

このスキルは設計工程で使用します。設計が固まった後は、タスク分解エージェントに引き継がれ、実装タスクに分解されます。
