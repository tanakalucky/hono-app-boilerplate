# システム設計のベストプラクティス

このガイドは、設計プロセスで参考にできるベストプラクティス集です。対話の中で必要に応じて提案してください。

## アーキテクチャパターン

### レイヤードアーキテクチャ

- **用途**: 中小規模のWebアプリ
- **メリット**: シンプル、理解しやすい、開発が早い
- **デメリット**: スケールしにくい、レイヤー間の依存が強くなりがち
- **適用例**: CRUD中心のWebアプリ、社内システム

### マイクロサービス

- **用途**: 大規模、複数チーム開発
- **メリット**: スケーラビリティ、独立デプロイ、技術スタック選択の自由度
- **デメリット**: 複雑性、運用コスト、分散システムの難しさ
- **適用例**: 大規模ECサイト、複数プロダクトを持つサービス

### イベント駆動アーキテクチャ

- **用途**: 非同期処理が多い、リアルタイム性が必要
- **メリット**: 疎結合、スケーラビリティ、拡張性
- **デメリット**: デバッグが難しい、イベントの順序制御が複雑
- **適用例**: 通知システム、データパイプライン、IoT

### ヘキサゴナルアーキテクチャ（ポート&アダプタ）

- **用途**: ビジネスロジックを外部依存から分離したい
- **メリット**: テスタビリティ、外部サービス切り替えが容易
- **デメリット**: 初期構築コスト、学習コスト
- **適用例**: ドメイン駆動設計（DDD）、長期保守が必要なシステム

---

## データベース設計

### 正規化 vs 非正規化

**正規化（第3正規形まで）**:

- **メリット**: データ整合性、更新異常の防止、ストレージ効率
- **デメリット**: JOIN多用でパフォーマンス低下
- **適用例**: トランザクション処理が多い、データ整合性が重要

**非正規化**:

- **メリット**: 読み取りパフォーマンス向上、JOINが不要
- **デメリット**: 更新時の整合性維持が複雑、ストレージ増加
- **適用例**: READ重視、分析系DB、レポート生成

### インデックス戦略

**基本方針**:

- WHERE句でよく使うカラムにインデックス
- JOINで使う外部キーにインデックス
- ORDER BYで使うカラムにインデックス

**注意点**:

- インデックス多すぎるとINSERT/UPDATEが遅くなる
- カーディナリティが低いカラム（性別など）はインデックス効果薄い
- 複合インデックスは順序が重要

### RDB vs NoSQL

**RDB（PostgreSQL, MySQL）**:

- **用途**: トランザクション処理、複雑なクエリ、データ整合性重視
- **メリット**: ACID保証、強力なクエリ言語（SQL）、成熟したエコシステム
- **デメリット**: スケールアウトが難しい（垂直スケール中心）

**NoSQL（MongoDB, DynamoDB）**:

- **用途**: 大量データ、スキーマ変更が頻繁、水平スケール必要
- **メリット**: スケーラビリティ、柔軟なスキーマ、高速な読み取り/書き込み
- **デメリット**: ACID保証が弱い、複雑なクエリが苦手

---

## API設計

### RESTful API

**基本原則**:

- リソースベースのURL設計（`/users`, `/posts`）
- HTTPメソッドを適切に使う（GET/POST/PUT/DELETE）
- ステートレス
- JSONフォーマット

**エンドポイント設計例**:

```
GET    /api/v1/users          # 一覧取得
GET    /api/v1/users/:id      # 詳細取得
POST   /api/v1/users          # 作成
PUT    /api/v1/users/:id      # 更新
DELETE /api/v1/users/:id      # 削除
```

**ページネーション**:

- クエリパラメータ: `?page=1&limit=20`
- レスポンスにtotal件数含める

**エラーハンドリング**:

- 適切なHTTPステータスコード（400, 401, 404, 500）
- エラーメッセージを含める

```json
{
  "error": {
    "code": "VALIDATION_ERROR",
    "message": "Email is required"
  }
}
```

### GraphQL

**用途**: フロントエンドが複雑、データ取得パターンが多様
**メリット**: 必要なデータだけ取得、型安全、ドキュメント自動生成
**デメリット**: 学習コスト、キャッシュが難しい、N+1問題

### gRPC

**用途**: マイクロサービス間通信、高速通信が必要
**メリット**: 高速（Protocol Buffers）、型安全、双方向ストリーミング
**デメリット**: ブラウザサポートが弱い、デバッグが難しい

---

## セキュリティ設計

### 認証

**JWT（JSON Web Token）**:

- **メリット**: ステートレス、スケーラブル、クロスドメイン対応
- **デメリット**: トークン無効化が難しい、サイズが大きい
- **適用例**: SPA、モバイルアプリ、マイクロサービス

**セッション**:

- **メリット**: サーバー側で管理、無効化が容易
- **デメリット**: サーバー側でセッション保持が必要、スケールしにくい
- **適用例**: 従来型Webアプリ

**OAuth2**:

- **用途**: 外部サービス連携（Google, Facebookログイン）
- **メリット**: 標準化、セキュア
- **デメリット**: 実装が複雑

### 認可

**RBAC（Role-Based Access Control）**:

- **用途**: ロールが明確（admin, user, guestなど）
- **メリット**: シンプル、理解しやすい
- **デメリット**: 柔軟性に欠ける

**ABAC（Attribute-Based Access Control）**:

- **用途**: 複雑な権限制御（部署、プロジェクト、時間など）
- **メリット**: 柔軟性が高い
- **デメリット**: 複雑、設計が難しい

### 暗号化

- **通信**: HTTPS必須（TLS 1.2以上）
- **パスワード**: bcrypt, Argon2でハッシュ化（絶対に平文保存しない）
- **機密情報**: DB暗号化（AWS RDS暗号化、Azure透過的暗号化など）
- **トークン**: ランダム生成、十分な長さ（128bit以上）

---

## パフォーマンス設計

### キャッシュ戦略

**Redis**:

- **用途**: セッション、頻繁にアクセスするデータ
- **TTL設定**: データの更新頻度に応じて設定（5分〜1時間）
- **キャッシュ削除**: 更新時にキャッシュクリア

**CDN（CloudFront, Cloudflare）**:

- **用途**: 静的ファイル（画像、CSS、JS）
- **メリット**: グローバル配信、高速、オリジンサーバーの負荷軽減

**ブラウザキャッシュ**:

- **用途**: 画像、CSS、JS
- **Cache-Control**: `max-age=31536000`（1年）でバージョニング併用

### データベース最適化

**インデックス**:

- 適切なインデックスで検索高速化
- EXPLAIN分析でスロークエリ特定

**クエリ最適化**:

- N+1問題を避ける（Eager Loading）
- 不要なカラムを取得しない（SELECT \*を避ける）
- JOINの順序を最適化

**コネクションプール**:

- DB接続を再利用
- プールサイズを適切に設定（CPU数 \* 2〜4程度）

---

## スケーラビリティ設計

### 水平スケール vs 垂直スケール

**水平スケール**:

- **方法**: サーバー台数を増やす
- **メリット**: 無限にスケール可能、障害耐性
- **デメリット**: ステートレス設計が必要、複雑性
- **適用例**: Webアプリ、APIサーバー

**垂直スケール**:

- **方法**: サーバースペックを上げる
- **メリット**: シンプル、実装容易
- **デメリット**: 上限がある、コストが高い
- **適用例**: DB、初期段階

### ロードバランサ

**用途**: 複数サーバーへのトラフィック分散
**種類**:

- **ALB（Application Load Balancer）**: HTTP/HTTPS、パスベースルーティング
- **NLB（Network Load Balancer）**: TCP/UDP、高速、低レイテンシ

### DBレプリケーション

**マスター-スレーブ**:

- **用途**: READ重視、スケーラビリティ
- **メリット**: READ分散、バックアップ
- **デメリット**: レプリケーション遅延

**マルチマスター**:

- **用途**: WRITE分散、高可用性
- **メリット**: WRITE分散、障害耐性
- **デメリット**: 競合解決が複雑

---

このガイドは参考情報です。実際の設計では、プロジェクトの要件や制約に応じて適切に選択してください。
