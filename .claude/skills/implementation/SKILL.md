---
name: implementation
description: 実装計画書を元に自動実装を行うスキル。コード実装、テスト作成、コミットを行い、エラー時は3回リトライする。振る舞い駆動テスト、Conventional Commits準拠、既存コード保護を含む。
---

# 実装スキル

このスキルは、実装計画書を元に自動的にコードとテストを実装し、コミットするプロセスを定義します。

## 目的

- 実装計画書のタスクを依存順に実装
- サブタスクごとにコード実装・テスト作成・コミット
- エラー時は自動リトライ、失敗時はユーザーに報告
- 振る舞い駆動テストで品質を保証
- Conventional Commits形式でコミット履歴を管理

## 前提条件

このスキルを使用する前に、以下が完了していること：

- 要件定義書が存在する（`.ai-workspace/{branch}/01-requirements.md`）
- 設計書が存在する（`.ai-workspace/{branch}/02-design.md`）
- 実装計画書が存在する（`.ai-workspace/{branch}/03-implementation-plan.md`）

**実装計画書の確認：**
実装を開始する前に、必ず `.ai-workspace/{branch}/03-implementation-plan.md` を確認してください。実装計画書が存在しない場合は、implementation-planner で実装計画を作成してから実装を開始してください。

## 実装プロセス

### フェーズ1: 初期化

1. **実装計画書を読み込む**
   - `.ai-workspace/{branch}/03-implementation-plan.md`

2. **設計書を読み込む**
   - `.ai-workspace/{branch}/02-design.md`

3. **未完了タスクを抽出**
   - 実装計画書からチェックマークがついていないタスクを抽出
   - 依存関係を確認してソート

4. **開発環境の確認**
   - 必要なパッケージがインストールされているか確認
   - ビルドツールが動作するか確認

---

### フェーズ2: タスク実行ループ

各タスクに対して以下のステップを実行：

#### ステップ1: 依存関係の確認

```
IF タスクに依存タスクがある THEN
  依存タスクがすべて完了しているか確認
  IF 未完了の依存タスクがある THEN
    次のタスクへスキップ
  END IF
END IF
```

#### ステップ2: サブタスク実行ループ

各サブタスクに対して以下を実行：

**2.1. コード実装**

- 設計書とタスク仕様を参照
- 既存コードの文脈を理解（serena tools使用）
- 新規ファイル作成 or 既存ファイル修正
- コーディング規約に従う（`.claude/skills/coding-guidelines/SKILL.md`参照）

**2.2. テスト実装**

- テスト戦略に従ってテストを作成（後述）
- 振る舞い駆動テスト（実装の詳細に依存しない）
- Vitestで実装（DOM操作が必要ならBrowser Mode）

**2.3. テスト実行**

- **成功** → 次のステップへ
- **失敗** → リトライ（最大3回）
  - 1回目：エラーメッセージを分析して修正
  - 2回目：別のアプローチで修正
  - 3回目：最終修正
  - 3回とも失敗 → 停止してユーザーに報告

**2.4. ビルド確認**

- **成功** → 次のステップへ
- **失敗** → リトライ（最大3回）
  - 同様のリトライロジック
  - 3回とも失敗 → 停止してユーザーに報告

**2.5. 既存テストの確認**
既存ファイルを修正した場合：

- **全テスト成功** → コミット可能
- **既存テストが失敗** → 修正前に戻す
  - 設計の見直しが必要な可能性をユーザーに報告

**2.6. コミット**

Conventional Commits形式でコミットします。サブタスクのメッセージをそのまま使用。

**2.7. 進捗報告**

```
✅ feat(api): User型とスキーマを定義 - コミット完了
```

#### ステップ3: タスク完了処理

すべてのサブタスクが完了したら：

1. 実装計画書にチェックマークを追加
2. タスク完了を報告
3. 次のタスクへ

---

### フェーズ3: 完了 or 停止

**全タスク完了時：**

```
🎉 全タスクが完了しました！

実装完了:
- タスク数: X個
- コミット数: Y個
- 実装時間: Z時間（見積もり）

次のステップ:
1. git push でリモートにプッシュ
2. Pull Requestを作成
3. レビューを依頼
```

**エラー停止時：**

```
❌ タスクX: サブタスクYで失敗しました

エラー内容:
[エラーメッセージ]

試みた修正:
1. [修正内容1]
2. [修正内容2]
3. [修正内容3]

推奨される次のアクション:
- エラーメッセージを確認してください
- 設計の見直しが必要かもしれません
- 手動で修正してから再実行してください
```

---

## テスト戦略

### 基本方針

- **テストピラミッド準拠**：ユニット多め、統合少なめ、E2E最小限
- **カバレッジ測定しない**：数値目標なし（質重視）
- **フレームワーク**：Vitest
- **Browser Mode**：DOM操作が必要なときのみ使用
- **振る舞い駆動テスト**：実装の詳細に依存しない

### テストの書き方

#### ✅ やること

**1. 振る舞いをテストする**

```typescript
// ✅ 良いテスト：振る舞いを確認
test("ユーザー登録に成功すると確認メールが送信される", async () => {
  const user = { email: "test@example.com", password: "pass123" };
  await registerUser(user);

  expect(mailService.send).toHaveBeenCalledWith({
    to: "test@example.com",
    subject: "登録確認",
  });
});
```

**2. 実装の詳細を隠す**

```typescript
// ✅ 良いテスト：実装の詳細を隠す
test("無効なメールアドレスでユーザー登録すると失敗する", async () => {
  const user = { email: "invalid-email", password: "pass123" };
  await expect(registerUser(user)).rejects.toThrow("Invalid email");
});
```

**3. 統合的にテストする**

単純な関数は、それを使う上位の関数で間接的にテストします。

#### ❌ やらないこと

**1. 単純な関数の直接テストは書かない**

```typescript
// ❌ 悪いテスト：プロダクションコードのコピー
test("isAdultは18歳以上でtrueを返す", () => {
  expect(isAdult(18)).toBe(true);
});
```

**2. 実装詳細に依存したテスト**

```typescript
// ❌ 悪いテスト：内部状態を確認
test("ユーザー登録時にuserCountが増える", async () => {
  const initialCount = getUserCount();
  await registerUser(user);
  expect(getUserCount()).toBe(initialCount + 1);
});
```

### Vitest Browser Modeの使い分け

**Browser Modeを使う場合：**

- DOM操作が必要なテスト
- ブラウザAPIが必要なテスト（localStorage, fetchなど）
- 実際のブラウザ環境での動作確認が必要

```typescript
import { test, expect } from "vitest";
import { page } from "@vitest/browser/context";

test("ログインフォームに入力して送信できる", async () => {
  await page.goto("/login");
  await page.fill('input[type="email"]', "user@example.com");
  await page.fill('input[type="password"]', "password123");
  await page.click('button[type="submit"]');

  // 振る舞い：ログイン成功後はダッシュボードに遷移
  await expect(page).toHaveURL("/dashboard");
});
```

**通常のVitestを使う場合：**

- 純粋なロジックのテスト
- APIクライアントのテスト
- ユーティリティ関数のテスト

```typescript
import { test, expect } from "vitest";

test("パスワードがハッシュ化される", async () => {
  const hashed = await hashPassword("password123");

  expect(hashed).not.toBe("password123");
  expect(hashed.length).toBeGreaterThan(20);
});
```

### テストの粒度

- **ユニットテスト**：個別の関数やクラスの振る舞いをテスト
- **統合テスト**：複数のモジュールが協調して動作することをテスト
- **E2Eテスト**：（フロントエンドは対象外）

---

## エラーハンドリング戦略

### テスト失敗時

1. **自動で3回リトライ**
2. **リトライごとに異なるアプローチ**：
   - 1回目：エラーメッセージを分析して原因を特定、修正
   - 2回目：別の実装アプローチを試す
   - 3回目：最小限の修正で動作させる
3. **3回とも失敗したら停止**
4. **ユーザーに報告**：
   - どのサブタスクで失敗したか
   - テストのエラーメッセージ
   - 試みた修正内容
   - 推奨される次のアクション

**報告フォーマット：**

```markdown
❌ タスク3: サブタスク2で失敗しました

サブタスク: feat(api): ログインエンドポイントを追加

テストエラー:
```

Expected response status 200, received 500
Error: Invalid password hash

```

試みた修正:
1. bcryptのコスト係数を10に変更
2. パスワード検証ロジックを修正
3. エラーハンドリングを追加

推奨される次のアクション:
- bcryptの設定を確認してください
- 手動でテストを実行してデバッグしてください
- 設計書のパスワードハッシュ化方式を見直してください
```

### ビルドエラー時

1. **自動で3回リトライ**
2. **リトライごとに異なるアプローチ**：
   - 1回目：型エラーを修正
   - 2回目：import/exportを修正
   - 3回目：依存関係を確認
3. **3回とも失敗したら停止**
4. **ユーザーに報告**

**報告フォーマット：**

```markdown
❌ ビルドエラーが発生しました

エラー内容:
```

Type 'string' is not assignable to type 'number'
at src/api/auth.ts:42:5

```

試みた修正:
1. 型定義を修正
2. 型アサーションを追加
3. 型ガードを追加

推奨される次のアクション:
- TypeScriptの型定義を確認してください
- 設計書のデータモデルと一致しているか確認してください
```

### 依存パッケージインストールエラー

1. **リトライしない**（環境問題の可能性が高い）
2. **即座にユーザーに報告**

**報告フォーマット：**

```markdown
❌ パッケージのインストールに失敗しました

パッケージ: bcrypt@5.1.0

エラー内容:
```

npm ERR! Could not resolve dependency

```

推奨される次のアクション:
- ネットワーク接続を確認してください
- npm cacheをクリアしてください: `npm cache clean --force`
- 手動でインストールしてください: `npm install bcrypt`
```

---

## コミット戦略

### Conventional Commits準拠

`.claude/skills/commit-convention/SKILL.md` に従います。

### サブタスク = 1コミット

実装計画書の各サブタスクが1コミットに対応します。サブタスクのメッセージをそのまま使用します。

---

## コード品質基準

### コーディング規約への準拠

すべてのコードは `.claude/skills/coding-guidelines/SKILL.md` で定義されたコーディング規約に従います。

### Linter/Formatter

Linterとフォーマッターはcommit hookで自動実行されるため、明示的にコマンドを実行する必要はありません。

---

## 既存コードの扱い

### 基本方針

- **新規ファイルの作成**：基本的に新しいファイルを作成
- **既存ファイルの修正**：タスクに必要なら既存ファイルも修正可能
- **既存テストの保護**：既存テストが失敗したら修正前に戻す

### 既存ファイル修正のフロー

```
1. 既存ファイルを修正
   ↓
2. 新しいテストを実行
   - 成功 → 次へ
   - 失敗 → リトライ（3回）
   ↓
3. 既存テストを実行
   - 成功 → コミット可能
   - 失敗 → 修正前に戻す
   ↓
4. 既存テストが失敗した場合
   - ユーザーに報告
   - 設計の見直しが必要な可能性を示唆
```

### 既存テスト失敗時の報告

```markdown
⚠️ 既存テストが失敗しました

タスク: feat(api): ログイン機能の拡張

失敗したテスト:

- test/api/auth.test.ts: "ユーザー認証が正しく動作する"

原因:
既存の認証ロジックに依存するテストが、新しい実装で壊れました。

推奨される次のアクション:

1. 設計書を確認して、既存機能への影響を見直してください
2. 既存テストを修正するか、設計を変更してください
3. 修正後、再度実装エージェントを実行してください

修正は行わずにロールバックしました。
```

---

## ベストプラクティス

### 1. 設計書を常に参照する

実装中は常に `.ai-workspace/{branch}/02-design.md` を参照し、設計意図を理解してください。

### 2. コミットは小さく保つ

1コミット = 1つの論理的変更を維持してください。サブタスクが大きすぎる場合は、実装計画書の見直しをユーザーに提案してください。

### 3. テストファーストで実装

可能な限り、テストを先に書いてから実装してください。テストが仕様を明確にします。

### 4. エラーメッセージは具体的に

エラーが発生したら、具体的なエラーメッセージをユーザーに報告してください。「エラーが発生しました」だけでは不十分です。

### 5. 進捗を可視化

サブタスクごとに進捗を報告し、ユーザーが状況を把握できるようにしてください。

---

## アンチパターン

### ❌ 実装計画書を無視する

実装計画書にないことを勝手に実装してはいけません。設計から外れる変更が必要な場合は、ユーザーに確認してください。

### ❌ エラーを無視して続行

テストやビルドが失敗したのに、無視して次のタスクに進んではいけません。必ず3回リトライし、失敗したら停止してください。

### ❌ 既存テストを削除

既存テストが失敗したからといって、テストを削除してはいけません。修正前に戻すか、ユーザーに報告してください。
